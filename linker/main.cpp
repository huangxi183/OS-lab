//Author: Xi Huang , created on: 14.Feb#include <iostream>#include <fstream>#include <map>#include <list>#include <vector>#include <set>#include <iomanip>#include <sstream>using namespace std;int machine_size = 512;int offset = 1;int defcount = 0, usecount = 0, codecount = 0;string line, token;int module_order = 1;//module orderint module_addr = 0; //module addressint line_number = 0;int pre_line_length = 0;int current_line_length = 0;int readtype = 0; // 0 readDef, 1 readUse, 2 readcodeint expected = 0; // 0 num_expected, 1 symbol_expected, 2 addr_expectedmap<string, int> deflist;//defined symbol tablemap<int, string> addr_symb;map<string, int> symb_in_module;list<string> symb_in_order;vector<string> use_list;map<int, int> module_to_addr;map<int, int> module_size;vector<bool> use_list_used;set<string> unused_symb;set<string> multiple_defines;void readDef(string&, int&, int&);void readUse(string&, int&, int&);void readCode(string&, int&, int&);void first_pass(fstream &p);void second_pass(fstream &p);void print_symb_table(); // print first pass symbol tablevoid print_addr(char t1, int t2, int module_order);void __parseerror(int errcode);string get_token(string &s, int &start, int &end);bool check_num(const string &p);bool check_sysmbo(const string &p);bool check_code(const string &p);string get_token(string &s, int &start, int &end){    int len = s.length();    while(start < len && (s.at(start) == '\t' || s.at(start) == ' ')){        if (s.at(start)=='\t'){            while (start<len && s.at(start)=='\t'){                start++;            }            //treat tabs as one character            offset++;        }        //skip the space        while (start<len && s.at(start)==' '){            start++;            offset++;        }    }    end = start;    while(end < len && s.at(end) != '\t' && s.at(end) != ' '){        end++;    }    return s.substr(start, end-start);}void print_symb_table(){    for(auto i = symb_in_order.begin(); i != symb_in_order.end(); i++){       cout << *i << '=' << deflist[*i];        //rule 2        if(multiple_defines.count(*i) > 0){            cout << " Error: This variable is multiple times defined; first value used";        }        cout<<'\n';    }    flush(cout);}bool check_num(const string &p){    istringstream sin(p);    double t;    char s;    if(!(sin >> t)){        if(expected == 0){            //parse error: number expected            __parseerror(0);            exit(1);        }        return false;    }    if(sin >> s){        if(expected == 0){            //parse error: number expected            __parseerror(0);            exit(1);        }        return false;    }    else        return true;}bool check_sysmbo(const string &p){    int i = 1;    if (('a'<= p.at(0) && p.at(0)<='z') || ('A'<= p.at(0) && p.at(0)<='Z')){        for (;i< p.length();i++){            if (('a'<= p.at(i) && p.at(i)<='z') || ('A'<= p.at(i) && p.at(i)<='Z') || ('0'<= p.at(i) && p.at(i)<='9'))                continue;            else                break;        }        if (i== p.length()) {            //parse error: symbol name too long            if(p.length() > 16){                __parseerror(3);                exit(1);            }            return true;        }    }    if(expected == 1){        //parse error: symbol expected        __parseerror(1);        exit(1);    }    return false;}bool check_code(const string &p){    if(p == "I" || p == "A" || p == "E" || p == "R"){        return true;    }    if(expected == 2){        //parse error: addressing expected        __parseerror(2);        exit(1);    }    return false;}//------first pass-------//void first_pass(fstream &p){    while(!p.eof()) {        int start = 0;        int end = 0;        offset = 1;        getline(p, line);        if(line.length() == 0 || line == "\n"){            pre_line_length = current_line_length;            current_line_length = line.length();            line_number++;            continue;        }       // module_to_addr[module_order] = module_addr;        line_number++;        pre_line_length = current_line_length;        current_line_length = line.length();        while(end < line.length()){            offset += (end - start);            start = end;            token = get_token(line, start, end);            if(token == "")                continue;            //read def list            if(readtype == 0){                readDef(token, start, end);            } else if(readtype == 1){                readUse(token, start, end);            } else if(readtype == 2){                readCode(token, start, end);            }        }    }    line_number--;    offset = pre_line_length +1;    if(expected != 0){        __parseerror(expected);        exit(1);    }}//------second pass-------//void second_pass(fstream &p){    int defcount, usecount, codecount;    int module_order = 0;    for(auto t = module_to_addr.begin(); t != module_to_addr.end(); ++t){        module_order++;        //pass2: def        p >> defcount;        for(int i = 0; i < defcount; i++) {            string t1;            int t2;            p >> t1;            p >> t2;        }        //pass2:use list        p >> usecount;        use_list.clear();        use_list_used.clear();        for(int i  = 0; i < usecount; i++){            string s;            p >> s;            use_list.push_back(s);            use_list_used.push_back(false);            unused_symb.erase(s);        }        //pass2:code        p >> codecount;        for(int i = 0; i < codecount; i++){            char t1;            int t2;            p >> t1 >> t2;            cout << setfill('0') << setw(3) << (t ->second + i);            cout << ": ";            print_addr(t1, t2, t->first);            cout << endl;        }        for(int i = 0; i < use_list_used.size(); i++){            //rule 7            if( !use_list_used[i]){                cout<< "Warning: Module " << module_order <<": "<< use_list[i] << " appeared in the uselist but was not actually used"<<endl;            }        }    }}void print_addr(char t1, int t2, int module_order){    int relative = t2 % 1000;    int opcode = t2 / 1000;    int absolute;    int result;    string error = "";    switch(t1){        case 'I':            if( (t2 / 10000)>=1){                //rule 10                result = 9999;                error = "Error: Illegal immediate value; treated as 9999";            }else{                absolute = relative;                result = absolute + 1000* opcode;            }            break;        case 'A':            absolute = relative;            //            if( (t2 / 10000)>=1){                //rule 11                result = 9999;                error = "Error: Illegal opcode; treated as 9999";            }            if( absolute > machine_size){                //rule 8                absolute = 0;                error = "Error: Absolute address exceeds machine size; zero used";            }            result = absolute + 1000* opcode;            break;        case 'R':            //rule 9            if( (t2 / 10000)>=1){                //rule 10                result = 9999;                error = "Error: Illegal opcode; treated as 9999";            }else if(relative > module_size[module_order]){                relative = 0;                //rule 9                error = "Error: Relative address exceeds module size; zero used";                absolute = relative + module_to_addr[module_order];                result = absolute + 1000* opcode;            }else{                absolute = relative + module_to_addr[module_order];                result = absolute + 1000* opcode;            }            break;        case 'E':            if( (t2 / 10000)>=1){                //rule 10                result = 9999;                error = "Error: Illegal opcode; treated as 9999";            }else if(relative >= use_list.size()){                //rule 6                absolute = relative ;                error = "Error: External address exceeds length of uselist; treated as immediate";                result = absolute + 1000* opcode;            } else{                //rule 3                auto symb = deflist.find(use_list[relative]);                if(symb == deflist.end()){                    error = "Error: "+ use_list[relative] + " is not defined; zero used";                    absolute = 0;                } else{                    absolute = symb -> second;                }                use_list_used[relative] = true;                result = absolute + 1000* opcode;            }            break;    }    cout << setfill('0') << setw(4) << result;    if(error.length() > 0){        cout<< ' '<< error;    }}int codetype = 0; // 0 codecount, 1 basestring code_t1;int code_t2;void readCode(string &token, int &start, int &end){    if(check_num(token)){        if(codetype == 0) {            codecount = atoi(token.c_str());            if (codecount == 0) {                expected = 0;                readtype = 0;            } else {                expected = 2;                codetype = 1;                for (auto i = symb_in_order.begin(); i != symb_in_order.end(); i++) {                    if (symb_in_module[*i] == module_order) {                        if ((deflist[*i] - module_addr) >= codecount) {                            //rule 5: too big                            cout << "Warning: Module " << module_order << ": " << *i << " too big "                                 << deflist[*i] - module_addr << " (max=" << codecount - 1 << ") assume zero relative"<<endl;                            deflist[*i] = module_addr;                        }                    }                }                module_size[module_order] = codecount;                module_addr += codecount;                if (module_addr > machine_size) {                    __parseerror(6);                    exit(1);                }                module_order++;            }        } else if(codetype == 1){            code_t2 = atoi(token.c_str());            codecount--;            expected = 2;            if(codecount == 0) {                codetype = 0;                readtype = 0;                expected = 0;            }        }    } else if(check_code(token)){        code_t1 = token;        expected = 2;    }}void readUse(string &token, int &start, int &end){    if(check_num(token) && expected == 0){        usecount = atoi(token.c_str());        expected = 1;        if(usecount > 16){            //parse error: too many use            __parseerror(5);            exit(1);        }else if(usecount == 0){            expected = 0;            readtype = 2;        }    }else if(check_sysmbo(token)){        usecount--;        use_list.push_back(token);        expected = 1;        if(usecount == 0) {            expected = 0;            readtype = 2;        }    }}int deftype = 0; // 0 defcount, 1 basestring def_t1;int def_t2;void readDef(string &token, int &start, int &end){    int base_addr = module_to_addr[module_order];    if(check_num(token) && deftype == 0){        module_to_addr[module_order] = module_addr;        defcount = atoi(token.c_str());        if(defcount>16){            //parse error: too many definitions            __parseerror(4);            exit(1);        } else if(defcount == 0){            expected = 0;            readtype = 1;        }        else{            expected = 1;            deftype = 1;        }    }else if(check_sysmbo(token)){        def_t1 = token;        expected = 0;    }else{        def_t2 = atoi(token.c_str());        pair<string, int> pair2(def_t1,module_order);        symb_in_module.insert(pair2);// record symbol used in which module        pair<string, int> pair3(def_t1, base_addr + def_t2);        pair<int, string> pair1(base_addr+def_t2, def_t1);        addr_symb.insert(pair1);        auto result = deflist.insert(pair3);        if(!result.second) {            multiple_defines.insert(def_t1);        }else{            unused_symb.insert(def_t1);            symb_in_order.push_back(def_t1);        }        defcount --;        expected = 1;        if(defcount == 0) {            deftype = 0;            readtype = 1;            expected = 0;        }    }}//parse errorvoid __parseerror(int errcode) {    static string errstr[] = {            "NUM_EXPECTED", // Number expect            "SYM_EXPECTED", // Symbol Expected            "ADDR_EXPECTED", // Addressing Expected which is A/E/I/R            "SYM_TOO_LONG", // Symbol Name is too long            "TO_MANY_DEF_IN_MODULE", // > 16            "TO_MANY_USE_IN_MODULE", // > 16            "TO_MANY_INSTR" //total num_instr exceeds memory size (512)    };    cout<< "Parse Error line " << line_number <<" offset " << offset << ": " << errstr[errcode] <<endl;}int main(int argc, char* argv[]) {    if(argc !=2){        cout<< "Wrong Number of arguments." <<endl;        exit(0);    }    string file_name = argv[1];    fstream inputfile;    inputfile.open(file_name.c_str());    if(!inputfile){        cout<< "Not a valid inputfile <" << argv[1] << ">" << endl;        return 1;    }    first_pass(inputfile);    cout<< "Symbol Table\n";    print_symb_table();    cout << '\n';    cout<< "Memory Map\n";    inputfile.clear();    inputfile.seekg(0);    second_pass(inputfile);    cout << '\n';    //rule 4: "Warning: Module %d: %s was defined but never used\n”    for(auto i = symb_in_order.begin(); i != symb_in_order.end(); i++){        if(unused_symb.count(*i) > 0 ){            cout << "Warning: Module " << symb_in_module[*i] << ": "<<*i <<" was defined but never used"<< endl;        }    }    cout<<'\n';    return 0;}